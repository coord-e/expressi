use expression::Expression;
use expression::Operator;

#[pub]
expression -> Expression
  = bin_op

bin_op -> Expression
  = #infix<infix_atom> {
  #L x "+" y { Expression::BinOp(Operator::Add, Box::new(x), Box::new(y)) }
     x "-" y { Expression::BinOp(Operator::Sub, Box::new(x), Box::new(y)) }
  #L x "*" y { Expression::BinOp(Operator::Mul, Box::new(x), Box::new(y)) }
     x "/" y { Expression::BinOp(Operator::Div, Box::new(x), Box::new(y)) }
  #L x "<" y { Expression::BinOp(Operator::Lt, Box::new(x), Box::new(y)) }
     x ">" y { Expression::BinOp(Operator::Gt, Box::new(x), Box::new(y)) }
     x "<=" y { Expression::BinOp(Operator::Le, Box::new(x), Box::new(y)) }
     x ">=" y { Expression::BinOp(Operator::Ge, Box::new(x), Box::new(y)) }
     x "==" y { Expression::BinOp(Operator::Eq, Box::new(x), Box::new(y)) }
     x "!=" y { Expression::BinOp(Operator::Ne, Box::new(x), Box::new(y)) }
  #L x "&" y { Expression::BinOp(Operator::BitAnd, Box::new(x), Box::new(y)) }
     x "^" y { Expression::BinOp(Operator::BitXor, Box::new(x), Box::new(y)) }
     x "|" y { Expression::BinOp(Operator::BitOr, Box::new(x), Box::new(y)) }
  #R x "=" y { Expression::Assign(Box::new(x), Box::new(y)) }
  #L x ";" y { Expression::Follow(Box::new(x), Box::new(y)) }
}

infix_atom -> Expression
  = _ v:atom _ { v }

atom -> Expression
  = number
  / boolean
  / identifier
  / "(" v:expression ")" { v }

identifier -> Expression
  = n:$([a-zA-Z] [a-zA-Z0-9_]*) { Expression::Identifier(n.to_owned()) }

number -> Expression
  = n:$([0-9]+) { Expression::Number(n.parse().unwrap()) }

boolean -> Expression
  = n:$("true" / "false") { Expression::Boolean(n.parse().unwrap()) }

_ = [ \t\n]*
