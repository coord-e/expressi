use expression::Expression;
use expression::Operator;

#[pub]
expression -> Expression
  = follow

follow -> Expression
  = l:bin_op ";" r:follow? { Expression::Follow(Box::new(l), Box::new(r.unwrap_or(Expression::Empty))) }
    / bin_op

bin_op -> Expression
  = #infix<spaced_atom> {
  #R x "=" y { Expression::Assign(Box::new(x), Box::new(y)) }
  #L x "|" y { Expression::BinOp(Operator::BitOr, Box::new(x), Box::new(y)) }
     x "^" y { Expression::BinOp(Operator::BitXor, Box::new(x), Box::new(y)) }
     x "&" y { Expression::BinOp(Operator::BitAnd, Box::new(x), Box::new(y)) }
  #L x "<" y { Expression::BinOp(Operator::Lt, Box::new(x), Box::new(y)) }
     x ">" y { Expression::BinOp(Operator::Gt, Box::new(x), Box::new(y)) }
     x "<=" y { Expression::BinOp(Operator::Le, Box::new(x), Box::new(y)) }
     x ">=" y { Expression::BinOp(Operator::Ge, Box::new(x), Box::new(y)) }
     x "==" y { Expression::BinOp(Operator::Eq, Box::new(x), Box::new(y)) }
     x "!=" y { Expression::BinOp(Operator::Ne, Box::new(x), Box::new(y)) }
  #L x "+" y { Expression::BinOp(Operator::Add, Box::new(x), Box::new(y)) }
     x "-" y { Expression::BinOp(Operator::Sub, Box::new(x), Box::new(y)) }
  #L x "*" y { Expression::BinOp(Operator::Mul, Box::new(x), Box::new(y)) }
     x "/" y { Expression::BinOp(Operator::Div, Box::new(x), Box::new(y)) }
}

if_else -> Expression
  = "if" cond:expression then_expr:expression else_expr:("else" v:spaced_atom {v})? { Expression::IfElse(Box::new(cond), Box::new(then_expr), Box::new(else_expr.unwrap_or(Expression::Empty))) }

cast -> Expression
  = l:atom _ "as" _ r:$([a-zA-Z] [a-zA-Z0-9_]*) { Expression::Cast(Box::new(l), r.parse().unwrap()) }

spaced_atom -> Expression
  = _ v:(cast / if_else / atom) _ { v }

atom -> Expression
  = number
  / boolean
  / identifier
  / "(" v:expression ")" { v }
  / "{" v:expression "}" { Expression::Scope(Box::new(v)) }

identifier -> Expression
  = n:$([a-zA-Z] [a-zA-Z0-9_]*) { Expression::Identifier(n.to_owned()) }

number -> Expression
  = n:$([0-9]+) { Expression::Number(n.parse().unwrap()) }

boolean -> Expression
  = n:$("true" / "false") { Expression::Boolean(n.parse().unwrap()) }

_ = [ \t\n]*
