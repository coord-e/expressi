use expression::Expression;
use expression::Operator;
use scope::BindingKind;

#[pub]
expression -> Expression
  = follow

follow -> Expression
  = l:assign ";" r:follow? { Expression::Follow(Box::new(l), Box::new(r.unwrap_or(Expression::Empty))) }
    / assign

assign -> Expression
  = l:bin_op "=" r:assign { Expression::Assign(Box::new(l), Box::new(r)) }
    / bin_op

bin_op -> Expression
  = #infix<spaced_atom> {
  #L x "|" y { Expression::BinOp(Operator::BitOr, Box::new(x), Box::new(y)) }
     x "^" y { Expression::BinOp(Operator::BitXor, Box::new(x), Box::new(y)) }
     x "&" y { Expression::BinOp(Operator::BitAnd, Box::new(x), Box::new(y)) }
  #L x "<" y { Expression::BinOp(Operator::Lt, Box::new(x), Box::new(y)) }
     x ">" y { Expression::BinOp(Operator::Gt, Box::new(x), Box::new(y)) }
     x "<=" y { Expression::BinOp(Operator::Le, Box::new(x), Box::new(y)) }
     x ">=" y { Expression::BinOp(Operator::Ge, Box::new(x), Box::new(y)) }
     x "==" y { Expression::BinOp(Operator::Eq, Box::new(x), Box::new(y)) }
     x "!=" y { Expression::BinOp(Operator::Ne, Box::new(x), Box::new(y)) }
  #L x "+" y { Expression::BinOp(Operator::Add, Box::new(x), Box::new(y)) }
     x "-" y { Expression::BinOp(Operator::Sub, Box::new(x), Box::new(y)) }
  #L x "*" y { Expression::BinOp(Operator::Mul, Box::new(x), Box::new(y)) }
     x "/" y { Expression::BinOp(Operator::Div, Box::new(x), Box::new(y)) }
}

if_else -> Expression
  = "if" cond:expression then_expr:expression else_expr:("else" v:spaced_atom {v})? { Expression::IfElse(Box::new(cond), Box::new(then_expr), Box::new(else_expr.unwrap_or(Expression::Empty))) }

cast -> Expression
  = l:atom _ "as" _ r:type_identifier { Expression::Cast(Box::new(l), Box::new(r)) }

index -> Expression
  = l:atom _ "[" r:expression "]" { Expression::BinOp(Operator::Index, Box::new(l), Box::new(r)) }

bind -> Expression
  = "let" _ kind:("mut" ?) _ l:identifier _ "=" r:assign { Expression::Bind(if kind.is_some() { BindingKind::Mutable } else { BindingKind::Immutable }, l.to_string(), Box::new(r)) }

spaced_atom -> Expression
  = _ v:(bind / cast / index / if_else / atom) _ { v }

atom -> Expression
  = number
  / boolean
  / array
  / value_identifier
  / type_
  / "{" v:expression "}" { Expression::Scope(Box::new(v)) }
  / "(" v:expression ")" { v }

value_identifier -> Expression
  = n:identifier { Expression::Identifier(n) }

identifier -> String
  = n:$([a-zA-Z] [a-zA-Z0-9_]*) { n.to_owned() }

number -> Expression
  = n:$([0-9]+) { Expression::Number(n.parse().unwrap()) }

boolean -> Expression
  = n:$("true" / "false") { Expression::Boolean(n.parse().unwrap()) }

array -> Expression
  = "[" e:(expression ** ',') "]" { Expression::Array(e.into_iter().map(|v| Box::new(v)).collect()) }

type_ -> Expression
  = "<" e:(type_elem  ++ "|") ">" { Expression::Type(e) }

type_identifier -> Expression
  = n:identifier { Expression::TypeIdentifier(n) }

type_elem -> (Expression, Vec<Expression>)
  = _ id:type_identifier _ "(" params:(type_identifier ** ",") _ ")" _ { (id, params) }

_ = [ \t\n]*
